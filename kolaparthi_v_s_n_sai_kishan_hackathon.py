# -*- coding: utf-8 -*-
"""Kolaparthi V S N SAI KISHAN_Hackathon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B07DuoLiOQG5Ywt_wXX2XfUlb8qX8A2Y
"""

# Step 0: Import required libraries
import pandas as pd
import sqlite3

# Step 1: Load Orders data from CSV
orders_df = pd.read_csv("orders.csv")

# Step 2: Load Users data from JSON
users_df = pd.read_json("users.json")

# Step 3: Load Restaurants data from SQL file into memory
conn = sqlite3.connect(":memory:")
with open("restaurants.sql", "r") as sql_file:
    sql_script = sql_file.read()
    conn.executescript(sql_script)

restaurants_df = pd.read_sql_query("SELECT * FROM restaurants", conn)

# Step 4: Merge datasets together
# Join orders with users, then with restaurants
combined_df = pd.merge(orders_df, users_df, on="user_id", how="left")
combined_df = pd.merge(combined_df, restaurants_df, on="restaurant_id", how="left")

# Step 5: Convert order_date column to datetime
# Use dayfirst=True to handle formats like '18-02-2023'
combined_df["order_date"] = pd.to_datetime(combined_df["order_date"], dayfirst=True, errors="coerce")

# Step 6: Quick check of the final dataset
print(combined_df.head())

# --- Order Trends Analysis ---

# Step 1: Extract month from order_date
combined_df["month"] = combined_df["order_date"].dt.to_period("M")

# Step 2: Orders per month
orders_per_month = combined_df.groupby("month")["order_id"].nunique()
print("Monthly Order Counts:\n", orders_per_month)

# Step 3: Revenue per month
monthly_revenue = combined_df.groupby("month")["total_amount"].sum()
print("\nMonthly Revenue:\n", monthly_revenue)

# Step 4: Revenue per quarter
combined_df["quarter"] = combined_df["order_date"].dt.to_period("Q")
quarterly_revenue = combined_df.groupby("quarter")["total_amount"].sum()
print("\nQuarterly Revenue:\n", quarterly_revenue)



# --- User Behavior Analysis ---

# Step 1: Calculate total spending by each user
user_spend = combined_df.groupby("user_id")["total_amount"].sum()
print("Total spend per user:\n", user_spend)

# Step 2: Compute average order value (AOV) for each user
user_aov = combined_df.groupby("user_id")["total_amount"].mean()
print("\nAverage order value per user:\n", user_aov)

# Step 3: Count number of orders placed by each user
orders_by_user = combined_df.groupby("user_id")["order_id"].count().sort_values(ascending=False)
print("\nOrders per user (sorted):\n", orders_by_user)

# Step 4: Identify repeat customers (users with >1 order)
repeat_customers = (combined_df.groupby("user_id")["order_id"].count() > 1).sum()
print("\nNumber of repeat customers:", repeat_customers)

# --- City-Level Performance Analysis ---

# Step 1: Revenue generated in each city
city_revenue = combined_df.groupby("city")["total_amount"].sum().sort_values(ascending=False)
print("Revenue by city:\n", city_revenue)

# Step 2: Number of orders placed in each city
city_orders = combined_df.groupby("city")["order_id"].nunique().sort_values(ascending=False)
print("\nOrders by city:\n", city_orders)

# Step 3: Average order value (AOV) for each city
city_aov = combined_df.groupby("city")["total_amount"].mean().round(2)
print("\nAverage order value by city:\n", city_aov)

# --- Cuisine-Level Performance Analysis ---

# Step 1: Total revenue generated by each cuisine
cuisine_revenue = combined_df.groupby("cuisine")["total_amount"].sum().sort_values(ascending=False)
print("Revenue by cuisine:\n", cuisine_revenue)

# Step 2: Number of orders placed for each cuisine
cuisine_orders = combined_df.groupby("cuisine")["order_id"].nunique().sort_values(ascending=False)
print("\nOrders by cuisine:\n", cuisine_orders)

# Step 3: Average order value (AOV) for each cuisine
cuisine_aov = combined_df.groupby("cuisine")["total_amount"].mean().round(2)
print("\nAverage order value by cuisine:\n", cuisine_aov)

# --- Membership Impact Analysis ---

# Step 1: Orders split by membership type
orders_split = combined_df.groupby("membership")["order_id"].nunique()
print("Orders split by membership:\n", orders_split)

# Step 2: Revenue contribution by membership type
revenue_split = combined_df.groupby("membership")["total_amount"].sum().sort_values(ascending=False)
print("\nRevenue split by membership:\n", revenue_split)

# Step 3: Average order value (AOV) comparison
aov_split = combined_df.groupby("membership")["total_amount"].mean().round(2)
print("\nAverage order value by membership:\n", aov_split)



# --- City with Highest Gold Member Revenue ---

# Step 1: Filter dataset for Gold membership
gold_df = combined_df.loc[combined_df["membership"] == "Gold"]

# Step 2: Aggregate revenue by city
gold_city_revenue = gold_df.groupby("city")["total_amount"].sum()

# Step 3: Identify the city with maximum revenue
top_city = gold_city_revenue.idxmax()
print("City with highest Gold member revenue:", top_city)

# --- Cuisine with Highest Average Order Value ---

# Step 1: Calculate average order value for each cuisine
cuisine_aov = combined_df.groupby("cuisine")["total_amount"].mean()

# Step 2: Identify the cuisine with the maximum AOV
top_cuisine = cuisine_aov.sort_values(ascending=False).index[0]

print("Cuisine with highest average order value:", top_cuisine)

# --- High-Value Customers Analysis ---

# Step 1: Calculate cumulative spend per user
spend_per_user = combined_df.groupby("user_id")["total_amount"].sum()

# Step 2: Filter users whose total spend exceeds ₹1000
high_value_users = spend_per_user[spend_per_user > 1000]

# Step 3: Count distinct users in this category
num_high_value_users = high_value_users.index.nunique()

print("Number of distinct users with spend > ₹1000:", num_high_value_users)

# --- Restaurant Rating Impact on Revenue ---

# Step 1: Aggregate revenue by rating
rating_revenue = combined_df.groupby("rating")["total_amount"].sum()

# Step 2: Find the rating range with maximum revenue
top_rating = rating_revenue.sort_values(ascending=False).index[0]

print("Rating range with highest total revenue:", top_rating)

# --- Gold Members: City with Highest AOV ---

# Step 1: Filter dataset for Gold membership
gold_users = combined_df.loc[combined_df["membership"] == "Gold"]

# Step 2: Compute average order value by city
gold_city_aov = gold_users.groupby("city")["total_amount"].mean()

# Step 3: Identify the city with the maximum AOV
top_gold_city = gold_city_aov.sort_values(ascending=False).index[0]

print("City with highest average order value among Gold members:", top_gold_city)

# --- Cuisine Efficiency Analysis ---

# Step 1: Group by cuisine and calculate metrics
cuisine_stats = (
    combined_df.groupby("cuisine")
    .agg(
        unique_restaurants=("restaurant_id", "nunique"),
        total_revenue=("total_amount", "sum")
    )
)

# Step 2: Sort by lowest restaurant count, then highest revenue
cuisine_sorted = cuisine_stats.sort_values(
    by=["unique_restaurants", "total_revenue"],
    ascending=[True, False]
)

# Step 3: Select the top cuisine
top_cuisine_eff = cuisine_sorted.head(1)
print("Cuisine with lowest restaurant count but high revenue:\n", top_cuisine_eff)

# --- Gold Members Order Share ---

# Step 1: Count total number of orders
total_orders = combined_df.shape[0]

# Step 2: Count orders placed by Gold members
gold_orders = combined_df.loc[combined_df["membership"] == "Gold"].shape[0]

# Step 3: Calculate percentage (rounded to nearest integer)
gold_order_pct = round((gold_orders / total_orders) * 100)

print("Percentage of orders placed by Gold members:", gold_order_pct, "%")

# --- High AOV Restaurants with Limited Orders ---

# Step 1: Summarize restaurant performance
restaurant_summary = (
    combined_df.groupby("restaurant_name_x")
    .agg(
        average_order_value=("total_amount", "mean"),
        order_volume=("order_id", "count")
    )
)

# Step 2: Keep only restaurants with fewer than 20 orders
filtered_restaurants = restaurant_summary[restaurant_summary["order_volume"] < 20]

# Step 3: Identify the restaurant with the highest AOV
top_small_restaurant = filtered_restaurants.sort_values(
    by="average_order_value", ascending=False
).head(1)

print("Restaurant with highest AOV but <20 orders:\n", top_small_restaurant)

df

# --- Membership & Cuisine Revenue Analysis ---

# Step 1: Aggregate revenue by membership and cuisine
combo_revenue = (
    combined_df.groupby(["membership", "cuisine"])["total_amount"]
    .sum()
)

# Step 2: Identify the combination with maximum revenue
top_combo = combo_revenue.sort_values(ascending=False).index[0]

print("Membership–Cuisine combination with highest revenue:", top_combo)

# --- Quarterly Revenue Analysis ---

# Step 1: Extract quarter information from order_date
combined_df["quarter"] = combined_df["order_date"].dt.to_period("Q")

# Step 2: Aggregate revenue by quarter
quarterly_revenue = combined_df.groupby("quarter")["total_amount"].sum()

# Step 3: Identify the quarter with maximum revenue
top_quarter = quarterly_revenue.sort_values(ascending=False).index[0]

print("Quarter with highest total revenue:", top_quarter)

# --- Gold Membership Order Count ---

# Step 1: Filter dataset for Gold membership
gold_orders_df = combined_df.loc[combined_df["membership"] == "Gold"]

# Step 2: Count total number of orders
total_gold_orders = gold_orders_df.shape[0]

print("Total orders placed by Gold members:", total_gold_orders)

# --- Hyderabad City Revenue Analysis ---

# Step 1: Filter dataset for Hyderabad city
hyd_orders = combined_df.loc[combined_df["city"] == "Hyderabad"]

# Step 2: Calculate total revenue
hyd_revenue = hyd_orders["total_amount"].sum()

# Step 3: Round to nearest integer
hyd_revenue_rounded = round(hyd_revenue)

print("Total revenue from Hyderabad city:", hyd_revenue_rounded)

# --- Distinct User Count Analysis ---

# Step 1: Count unique users who placed orders
unique_users = combined_df["user_id"].nunique()

print("Number of distinct users who placed at least one order:", unique_users)

# --- Gold Members Average Order Value ---

# Step 1: Filter dataset for Gold membership
gold_orders = combined_df.loc[combined_df["membership"] == "Gold"]

# Step 2: Calculate average order value
gold_aov = gold_orders["total_amount"].mean()

# Step 3: Round to 2 decimal places
gold_aov_rounded = round(gold_aov, 2)

print("Average order value for Gold members:", gold_aov_rounded)

# --- High-Rated Restaurants Order Count ---

# Step 1: Filter dataset for restaurants with rating ≥ 4.5
high_rated_orders = combined_df.loc[combined_df["rating"] >= 4.5]

# Step 2: Count total number of orders
num_high_rated_orders = high_rated_orders["order_id"].count()

print("Number of orders for restaurants with rating ≥ 4.5:", num_high_rated_orders)

# --- Gold Members: Orders in Top Revenue City ---

# Step 1: Identify the city with maximum revenue among Gold members
top_gold_city = (
    combined_df.loc[combined_df["membership"] == "Gold"]
    .groupby("city")["total_amount"]
    .sum()
    .sort_values(ascending=False)
    .index[0]
)

# Step 2: Count orders placed in that city by Gold members
orders_in_top_gold_city = combined_df[
    (combined_df["membership"] == "Gold") & (combined_df["city"] == top_gold_city)
]["order_id"].count()

print("Number of orders in top revenue city (Gold members):", orders_in_top_gold_city)

# --- Merge Orders and Users ---
merged_data = pd.merge(orders, users, how="inner", left_on="user_id", right_on="user_id")
print("Join column:", "user_id")

# --- Cuisine & Rating Source ---
# Data for cuisine and rating comes from restaurants.sql
print("Dataset format:", "restaurants.sql")

# --- Final Dataset Row Count ---
row_count = len(df)
print("Total rows in merged dataset:", row_count)  # Output: 10000

# --- Merge Behavior with Missing Records ---
merged_df = pd.merge(orders, users, on="user_id", how="left")

# If a user_id exists in orders but not in users.json,
# the corresponding fields from users will appear as NaN.
print("Missing values in merge result:", "NULL / NaN")

# --- Dataset Combination Function ---
combined_df = pd.merge(orders, users, on="user_id", how="inner")

print("Function used to combine datasets:", "merge()")

# --- Final Dataset Q&A ---

# Q1: The column membership in the final dataset originates from the __________ file
print("ANS Q1:", "users.json")

# Q2: The join key used to combine orders data with restaurant details is __________
print("ANS Q2:", "orders.restaurant_id to restaurants.restaurant_id")

# Q3: The column that helps identify the type of food served by a restaurant is __________
print("ANS Q3:", "cuisine")

# Q4: If a user places multiple orders, their personal details appear __________ times in the final merged dataset
print("ANS Q4:", "once per order")

